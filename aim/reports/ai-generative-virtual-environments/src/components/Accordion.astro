---
/**
 * Accordion.astro
 * Expandable sections with smooth animations
 * Uses data attributes for panel identification instead of dynamic slots
 */

interface AccordionItem {
  id: string;
  title: string;
  content?: string;
  defaultOpen?: boolean;
}

interface Props {
  items: AccordionItem[];
  allowMultiple?: boolean;
}

const { items, allowMultiple = true } = Astro.props;

const accordionId = `accordion-${Math.random().toString(36).slice(2, 9)}`;
---

<div
  class="accordion"
  data-accordion
  data-allow-multiple={allowMultiple ? 'true' : 'false'}
  id={accordionId}
>
  {items.map((item, index) => (
    <div class="accordion__item" data-accordion-item data-item-id={item.id}>
      <h3 class="accordion__heading">
        <button
          type="button"
          class="accordion__trigger"
          id={`${accordionId}-trigger-${item.id}`}
          aria-controls={`${accordionId}-panel-${item.id}`}
          aria-expanded={item.defaultOpen ? 'true' : 'false'}
          data-accordion-trigger
        >
          <span class="accordion__title">{item.title}</span>
          <svg
            class="accordion__icon"
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            aria-hidden="true"
          >
            <path
              d="M5 8l5 5 5-5"
              stroke="currentColor"
              stroke-width="2"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
      </h3>
      <div
        class="accordion__panel"
        id={`${accordionId}-panel-${item.id}`}
        role="region"
        aria-labelledby={`${accordionId}-trigger-${item.id}`}
        hidden={!item.defaultOpen}
        data-accordion-panel
      >
        <div class="accordion__content">
          {item.content && (
            <p set:html={item.content} />
          )}
        </div>
      </div>
    </div>
  ))}

  <!-- Slot for custom content that can be placed in specific panels -->
  <div class="accordion__slot-content" hidden>
    <slot />
  </div>
</div>

<style>
  .accordion {
    width: 100%;
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    overflow: hidden;
  }

  .accordion__slot-content {
    display: none;
  }

  .accordion__item {
    border-bottom: 1px solid var(--color-border);
  }

  .accordion__item:last-of-type {
    border-bottom: none;
  }

  .accordion__heading {
    margin: 0;
  }

  .accordion__trigger {
    display: flex;
    align-items: center;
    justify-content: space-between;
    width: 100%;
    padding: var(--space-4);
    background-color: var(--color-surface);
    border: none;
    text-align: left;
    cursor: pointer;
    transition: background-color var(--transition-fast);
  }

  .accordion__trigger:hover {
    background-color: var(--color-surface-alt);
  }

  .accordion__trigger:focus-visible {
    outline: 2px solid var(--color-primary);
    outline-offset: -2px;
  }

  .accordion__title {
    font-size: var(--font-size-base);
    font-weight: 600;
    color: var(--color-text);
  }

  .accordion__icon {
    flex-shrink: 0;
    color: var(--color-text-muted);
    transition: transform var(--transition-fast);
  }

  .accordion__trigger[aria-expanded="true"] .accordion__icon {
    transform: rotate(180deg);
  }

  .accordion__panel {
    overflow: hidden;
  }

  .accordion__panel[hidden] {
    display: none;
  }

  .accordion__content {
    padding: 0 var(--space-4) var(--space-4);
    color: var(--color-text);
    line-height: var(--line-height-relaxed);
  }

  .accordion__content :global(p:first-child) {
    margin-top: 0;
  }

  .accordion__content :global(p:last-child) {
    margin-bottom: 0;
  }

  .accordion__content :global(ul),
  .accordion__content :global(ol) {
    margin: var(--space-2) 0;
    padding-left: var(--space-6);
  }

  /* Animation for smooth open/close */
  @keyframes accordionSlideDown {
    from {
      opacity: 0;
      transform: translateY(-8px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  .accordion__panel:not([hidden]) .accordion__content {
    animation: accordionSlideDown var(--transition-base) ease-out;
  }

  /* Variant: Bordered */
  .accordion--bordered .accordion__item {
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    margin-bottom: var(--space-2);
  }

  .accordion--bordered .accordion__item:last-of-type {
    margin-bottom: 0;
    border-bottom: 1px solid var(--color-border);
  }

  /* Variant: Flush (no borders) */
  .accordion--flush {
    border: none;
    border-radius: 0;
  }

  .accordion--flush .accordion__item {
    border-bottom: 1px solid var(--color-border);
  }
</style>

<script>
  document.querySelectorAll('[data-accordion]').forEach(accordion => {
    const allowMultiple = accordion.getAttribute('data-allow-multiple') === 'true';
    const triggers = accordion.querySelectorAll('[data-accordion-trigger]');

    triggers.forEach(trigger => {
      trigger.addEventListener('click', () => {
        const isExpanded = trigger.getAttribute('aria-expanded') === 'true';
        const panel = document.getElementById(
          trigger.getAttribute('aria-controls') || ''
        );

        // If not allowing multiple, close others first
        if (!allowMultiple && !isExpanded) {
          triggers.forEach(otherTrigger => {
            if (otherTrigger !== trigger) {
              otherTrigger.setAttribute('aria-expanded', 'false');
              const otherPanel = document.getElementById(
                otherTrigger.getAttribute('aria-controls') || ''
              );
              if (otherPanel) otherPanel.hidden = true;
            }
          });
        }

        // Toggle current
        trigger.setAttribute('aria-expanded', String(!isExpanded));
        if (panel) panel.hidden = isExpanded;
      });
    });

    // Keyboard navigation
    accordion.addEventListener('keydown', (e: Event) => {
      const event = e as KeyboardEvent;
      const trigger = event.target as HTMLElement;

      if (!trigger.matches('[data-accordion-trigger]')) return;

      const triggersArray = Array.from(triggers) as HTMLElement[];
      const currentIndex = triggersArray.indexOf(trigger);

      let newIndex: number | null = null;

      switch (event.key) {
        case 'ArrowUp':
          newIndex = currentIndex > 0 ? currentIndex - 1 : triggersArray.length - 1;
          break;
        case 'ArrowDown':
          newIndex = currentIndex < triggersArray.length - 1 ? currentIndex + 1 : 0;
          break;
        case 'Home':
          newIndex = 0;
          break;
        case 'End':
          newIndex = triggersArray.length - 1;
          break;
      }

      if (newIndex !== null) {
        event.preventDefault();
        triggersArray[newIndex].focus();
      }
    });
  });
</script>
